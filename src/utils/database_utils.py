# database_utils.py
from sqlalchemy import create_engine
import mysql.connector
from datetime import datetime, timedelta

def connect_to_database():
    """
    Établit une connexion à la base de données MySQL.

    :return: Objet de connexion à la base de données.
    """
    try:
        # Paramètres de connexion à la base de données
        config = {
            'user': 'sokoloff',
            'password': 'CEpubliEXPL59',
            'host': 'da18272-003.eu.clouddb.ovh.net',
            'port': 35632,
            'database': 'CEpublicationEXPL'
        }

        # Établissement de la connexion
        conn = mysql.connector.connect(**config)

        return conn

    except mysql.connector.Error as e:
        print(f"Erreur lors de la connexion à la base de données : {e}")
        raise


def log_to_database(id_alim, periode, date_heure, nom_fichier, description, importance, type_log):
    """
    Écrit un log dans la base de données.

    :param id_alim (int): ID de l'alimentation.
    :param periode (str): Période (dateDebut_dateFin).
    :param date_heure (Datetime): Date et heure du log.
    :param nom_fichier (str): Nom du fichier associé au log.
    :param description (str): Description du log.
    :param importance (int): Importance du log.
    :param type_log (str): Type de log (INFO, WARNING, ERROR).
    """
    try:
        # Connexion à la base de données
        conn = connect_to_database()
        cursor = conn.cursor()
        
        # Requête SQL pour insérer le log dans la table Log
        query = "INSERT INTO Log (Id_boucle, Periode, DateHeure, NomFichier, Description, Importance, Type) VALUES (%s, %s, %s, %s, %s, %s, %s)"        
        values = (id_alim, periode, date_heure, nom_fichier, description, importance, type_log)
        
        # Exécution de la requête
        cursor.execute(query, values)
        conn.commit()
    
    except mysql.connector.Error as e:
        print(f"Erreur lors de l'écriture du log dans la base de données : {e}")
    
    finally:
        # Fermeture de la connexion à la base de données
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()
            

def insert_data_to_mysql(df, num_boucle, periode):
    """
    Insère les données du DataFrame dans une table MySQL.
    
    :param df (DataFrame): DataFrame contenant les données à insérer
    :param num_boucle (int): Numéro de la boucle d'autoconsommation.
    :param periode (str): Période (dateDebut_dateFin).
    """
    # Paramètres de connexion à la base de données MySQL
    db_host = 'da18272-003.eu.clouddb.ovh.net:35632'
    db_user = 'sokoloff'
    db_password = 'CEpubliEXPL59'
    db_name = 'CEpublicationEXPL'
    table_name = 'Mesure'
    
    try:
        # Créer la chaîne de connexion
        connection_string = f'mysql+pymysql://{db_user}:{db_password}@{db_host}/{db_name}'
        engine = create_engine(connection_string)
        
        # Insérer les données du DataFrame dans la table MySQL
        df.to_sql(name=table_name, con=engine, if_exists='append', index=False)
        
        log_to_database(num_boucle, periode, datetime.now(), "", "Les données ont été insérées avec succès dans la table MySQL.", 2, "INFO")
    except Exception as e:
        # Enregistrer un message d'erreur dans le journal en cas d'échec de l'insertion des données
        log_to_database(num_boucle, periode, datetime.now(), "", f"Erreur lors de l'insertion des données dans la table MySQL : {str(e)}", 2, "ERROR")
        

def delete_old_logs(num_boucle, periode):
    """
    Supprime les logs de la table "Log" qui sont anciens de 3 mois.
    
    :param num_boucle (int): Numéro de la boucle d'autoconsommation.
    :param periode (str): Période (dateDebut_dateFin).
    """
    try:
        # Connexion à la base de données
        conn = connect_to_database()
        cursor = conn.cursor()
        
        # Calculer la date d'il y a 3 mois
        three_months_ago = datetime.now() - timedelta(days=90)
        
        # Requête SQL pour supprimer les logs anciens de 3 mois
        query = "DELETE FROM Log WHERE DateHeure < %s"
        values = (three_months_ago,)
        # DELETE FROM Log
        # WHERE DateHeure < DATE_SUB(NOW(), INTERVAL 3 MONTH);
        
        # Exécution de la requête
        cursor.execute(query, values)
        rows_deleted = cursor.rowcount
        conn.commit()
        
        # Enregistrer un message de succès dans le journal
        log_to_database(num_boucle, periode, datetime.now(), "", f"Les logs anciens de 3 mois ont été supprimés avec succès. {rows_deleted} lignes ont été supprimées.", 1, "INFO")

    except mysql.connector.Error as e:
        # Enregistrer un message d'erreur dans le journal en cas d'échec de la suppression des logs
        log_to_database(num_boucle, periode, datetime.now(), "", f"Erreur lors de la suppression des logs anciens de 3 mois : {e}", 2, "ERROR")
    
    finally:
        # Fermeture de la connexion à la base de données
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()
            

def remove_duplicates(num_boucle, periode):
    """
    Supprime les doublons de la table 'Mesure' de la base de données.

    :param num_boucle (int): Numéro de la boucle d'autoconsommation.
    :param periode (str): Période (dateDebut_dateFin).
    """
    try:
        # Connexion à la base de données
        conn = connect_to_database()
        cursor = conn.cursor()

        # Obtenir le nombre de lignes avant la suppression des doublons
        get_row_count_query = "SELECT COUNT(*) FROM Mesure;"
        cursor.execute(get_row_count_query)
        row_count_before = cursor.fetchone()[0]

        # Création d'une table temporaire avec les enregistrements uniques
        create_temp_table_query = """
        CREATE TEMPORARY TABLE temp_table
        SELECT DISTINCT Id_boucle, PRM_prod, PRM_conso, Attribut, Date_debut, Date_fin, Valeur, Granularite, Respo, Classe, Etat
        FROM Mesure;
        """
        cursor.execute(create_temp_table_query)

        # Vidage de la table 'Mesure'
        truncate_table_query = "TRUNCATE TABLE Mesure;"
        cursor.execute(truncate_table_query)

        # Insertion des enregistrements uniques dans la table 'Mesure'
        insert_unique_records_query = """
        INSERT INTO Mesure (Id_boucle, PRM_prod, PRM_conso, Attribut, Date_debut, Date_fin, Valeur, Granularite, Respo, Classe, Etat)
        SELECT Id_boucle, PRM_prod, PRM_conso, Attribut, Date_debut, Date_fin, Valeur, Granularite, Respo, Classe, Etat
        FROM temp_table;
        """
        cursor.execute(insert_unique_records_query)

        # Obtenir le nombre de lignes après la suppression des doublons
        get_row_count_query = "SELECT COUNT(*) FROM Mesure;"
        cursor.execute(get_row_count_query)
        row_count_after = cursor.fetchone()[0]

        # Calculer le nombre de lignes supprimées (doublons)
        rows_removed = row_count_before - row_count_after

        # Suppression de la table temporaire
        drop_temp_table_query = "DROP TEMPORARY TABLE temp_table;"
        cursor.execute(drop_temp_table_query)

        conn.commit()

        if rows_removed > 0:
            # Enregistrer un message de succès dans le journal
            log_to_database(num_boucle, periode, datetime.now(), "", f"Les doublons ont été supprimés avec succès de la table 'Mesure'. {rows_removed} lignes ont été supprimées.", 2, "ERROR")
        else:
            # Enregistrer un message de succès dans le journal
            log_to_database(num_boucle, periode, datetime.now(), "", f"Les doublons ont été supprimés avec succès de la table 'Mesure'. {rows_removed} lignes ont été supprimées.", 1, "INFO")

    except mysql.connector.Error as e:
        # Enregistrer un message d'erreur dans le journal en cas d'échec de la suppression des doublons
        log_to_database(num_boucle, periode, datetime.now(), "", f"Erreur lors de la suppression des doublons de la table 'Mesure' : {e}", 2, "ERROR")

    finally:
        # Fermeture de la connexion à la base de données
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()
            
def delete_test_logs(num_boucle, periode):
    """
    Supprime les lignes de la table 'Log' où la colonne 'Id_boucle' vaut 'test_numboucle'.
    
    :param num_boucle (int): Numéro de la boucle d'autoconsommation.
    :param periode (str): Période (dateDebut_dateFin).
    """
    try:
        # Connexion à la base de données
        conn = connect_to_database()
        cursor = conn.cursor()
        
        # Requête SQL pour supprimer les logs avec 'Id_boucle' = 'test_numboucle'
        query = "DELETE FROM Log WHERE Id_boucle = 'test_numboucle' OR Periode = 'test_date1_date2'"
        
        # Exécution de la requête
        cursor.execute(query)
        rows_deleted = cursor.rowcount
        conn.commit()
        
        # Enregistrer un message de succès dans le journal
        log_to_database(num_boucle, periode, datetime.now(), "", f"Les logs avec Id_boucle = 'test_numboucle' ont été supprimés avec succès. {rows_deleted} lignes ont été supprimées.", 1, "INFO")

    except mysql.connector.Error as e:
        # Enregistrer un message d'erreur dans le journal en cas d'échec de la suppression des logs
        log_to_database(num_boucle, periode, datetime.now(), "", f"Erreur lors de la suppression des logs avec Id_boucle = 'test_numboucle' : {e}", 2, "ERROR")
    
    finally:
        # Fermeture de la connexion à la base de données
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()
