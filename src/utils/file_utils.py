# file_utils.py
import os
import fnmatch
import shutil
from .database_utils import log_to_database
from datetime import datetime

def create_directory(folder_path):
    """
    Créer le répertoire s'il n'existe pas.

    :param folder_path (str): Chemin du répertoire à créer.
    """
    # Vérifier si le répertoire n'existe pas et le créer s'il est inexistant
    if not os.path.exists(folder_path):
        os.makedirs(folder_path)
        

def move_zip_to_directory(email, folder_path, zip_filename, num_boucle, periode):
    """
    Déplacer le fichier ZIP dans le répertoire.

    :param email (email.message.Message): Objet Email contenant le fichier ZIP.
    :param folder_path (str): Chemin du répertoire de destination.
    :param zip_filename (str): Nom du fichier ZIP à déplacer.
    :param num_boucle (int): Numéro de la boucle d'autoconsommation.
    :param periode (str): Période (dateDebut_dateFin).
    """
    try:
        # Parcourir les parties de l'email
        for part in email.walk():
            # Vérifier si la partie est le fichier ZIP recherché
            if part.get_filename() == zip_filename:
                # Obtenir les données du fichier ZIP
                zip_data = part.get_payload(decode=True)
                # Chemin complet du fichier ZIP dans le répertoire de destination
                zip_filepath = os.path.join(folder_path, zip_filename)
                # Écrire les données du fichier ZIP dans le fichier
                with open(zip_filepath, 'wb') as f:
                    f.write(zip_data)
                log_to_database(num_boucle, periode, datetime.now(), f"{zip_filename}", f"Fichier déplacé avec succès dans '{folder_path}'.", 1, "INFO")
    except Exception as e:
        # Enregistrer une erreur s'il y a un problème lors du déplacement du fichier ZIP
        log_to_database(num_boucle, periode, datetime.now(), f"{zip_filename}", f"Erreur lors du déplacement du fichier ZIP : {e}", 2, "ERROR")
        
        
def get_first_directory_name(directory):
    """
    Obtenir le nom du premier répertoire dans un dossier.

    :param directory (str): Chemin du dossier à rechercher.
    :return (str or None): Nom du premier répertoire trouvé ou None s'il n'y en a aucun.
    """
    # Parcourir les fichiers et répertoires dans le dossier spécifié
    for file_name in os.listdir(directory):
        # Chemin complet du fichier ou répertoire
        file_path = os.path.join(directory, file_name)
        # Vérifier si c'est un répertoire
        if os.path.isdir(file_path):
            # Retourner le nom du premier répertoire trouvé
            return file_name
    # Si aucun répertoire n'est trouvé, retourner None
    return None


def list_zip_files(directory):
    """
    Renvoie une liste des fichiers zip dans le répertoire spécifié.

    :param directory (str): Chemin du répertoire à rechercher.
    :return (list): Liste des noms des fichiers zip.
    """
    # Liste pour stocker les noms des fichiers zip
    zip_files = []
    
    # Parcourir récursivement tous les fichiers et répertoires dans le dossier spécifié
    for root, dirs, files in os.walk(directory):
        # Parcourir tous les fichiers dans le répertoire actuel, Vérifier si le fichier a une extension .zip
        for filename in fnmatch.filter(files, '*.zip'):
            # Ajouter le nom du fichier zip à la liste
            zip_files.append(filename)
            
    # Retourner la liste des fichiers zip
    return zip_files
        
        
def compresser_dossier(dossier_path, archive_path, num_boucle, periode):
    """
    Compresse le dossier spécifié dans un fichier ZIP.
    
    :param dossier_path (str): Chemin vers le dossier à compresser.
    :param archive_path (str): Chemin complet (incluant le nom de fichier) où l'archive ZIP sera sauvegardée.
    :param num_boucle (int): Numéro de la boucle d'autoconsommation.
    :param periode (str): Période (dateDebut_dateFin).
    :return (bool): True si la compression a réussi, False sinon.
    """
    try:
        # Compresser le dossier
        shutil.make_archive(archive_path, 'zip', dossier_path)
        log_to_database(num_boucle, periode, datetime.now(), f"{dossier_path}", f"Compressé avec succès en {archive_path}.zip", 1, "INFO")
        return True  # Renvoie True si la compression a réussi
    except Exception as e:
        log_to_database(num_boucle, periode, datetime.now(), f"{dossier_path}", f"Erreur lors de la compression du dossier : {e}", 2, "ERROR")
        return False  # Renvoie False si une erreur s'est produite lors de la compression
    
    
def supprimer_fichier(fichier_path, num_boucle, periode):
    """
    Supprime le fichier spécifié.
    
    :param fichier_path (str): Chemin complet vers le fichier à supprimer.
    :param num_boucle (int): Numéro de la boucle d'autoconsommation.
    :param periode (str): Période (dateDebut_dateFin).
    """
    try:
        # Vérifier si le fichier existe
        if os.path.exists(fichier_path):
            # Supprimer le fichier s'il existe
            os.remove(fichier_path)
            log_to_database(num_boucle, periode, datetime.now(), f"{fichier_path}", "Le fichier a été supprimé avec succès.", 1, "INFO")
        else:
            log_to_database(num_boucle, periode, datetime.now(), f"{fichier_path}", "Le fichier n'existe pas.", 2, "WARNING")
    except Exception as e:
        # Capturer toute erreur qui pourrait survenir lors de la suppression du fichier
        log_to_database(num_boucle, periode, datetime.now(), f"{fichier_path}", f"Erreur lors de la suppression du fichier : {e}", 2, "ERROR")
    
    
def get_first_zip_file(directory):
    """
    Obtient le nom du premier fichier ZIP dans le répertoire spécifié.

    :param directory (str): Chemin du répertoire à rechercher.
    :return (str or None): Nom du premier fichier ZIP trouvé ou None s'il n'y en a aucun.
    """
    for file_name in os.listdir(directory):
        file_path = os.path.join(directory, file_name)
        # Vérifier si le chemin est un fichier et s'il se termine par .zip
        if os.path.isfile(file_path) and file_name.endswith('.zip'):
            return file_name
    return None
    
    
def delete_directory(directory, num_boucle, periode):
    """
    Supprimer le répertoire spécifié.

    :param directory (str): Chemin du répertoire à supprimer.
    :param num_boucle (int): Numéro de la boucle d'autoconsommation.
    :param periode (str): Période (dateDebut_dateFin).
    """
    try:
        shutil.rmtree(directory) # Supprime le répertoire et tous ses contenus
        log_to_database(num_boucle, periode, datetime.now(), f"{directory}", "Répertoire supprimé avec succès.", 1, "INFO")
    except Exception as e:
        log_to_database(num_boucle, periode, datetime.now(), f"{directory}", f"Erreur lors de la suppression du répertoire : {e}", 2, "ERROR")
        