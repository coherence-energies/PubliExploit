# email_utils.py
import email
import os
from email_validator import validate_email, EmailNotValidError
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.base import MIMEBase
import urllib.parse
import smtplib
import ssl
from email import encoders
from .database_utils import connect_to_database, log_to_database
from datetime import datetime
from bs4 import BeautifulSoup


def extract_email_body(email, num_boucle, periode):
    """
    Extrait le corps textuel de l'e-mail.

    :param email (email.message.Message): L'objet Message représentant l'e-mail.
    :param num_boucle (int): Numéro de la boucle d'autoconsommation.
    :param periode (str): Période (dateDebut_dateFin).
    :return (str): Le corps textuel de l'e-mail.
    """
    try:
        body = ""
        if email.is_multipart():
            for part in email.walk():
                content_type = part.get_content_type()
                if content_type == 'text/plain':
                    body = part.get_payload(decode=True).decode('utf-8', 'ignore')
                    break
                elif content_type == 'text/html':
                    html_content = part.get_payload(decode=True).decode('utf-8', 'ignore')
                    # Utiliser BeautifulSoup pour extraire le texte du HTML
                    soup = BeautifulSoup(html_content, 'html.parser')
                    body = soup.get_text()
                    # Alternativement, vous pouvez utiliser html2text
                    # body = html2text.html2text(html_content)
                    break
        else:
            body = email.get_payload(decode=True).decode('utf-8', 'ignore')
        
        # Nettoyage supplémentaire si nécessaire
        body = body.strip()
        
        return body
    except Exception as e:
        log_to_database(num_boucle, periode, datetime.now(), "", f"Erreur lors de l'extraction du corps de l'e-mail : {e}", 2, "ERROR")
        return ""
 
    
def decode_email_subject(encoded_subject):
    """
    Décoder le sujet de l'e-mail.

    :param encoded_subject (str): Le sujet de l'e-mail encodé.
    :return (str): Le sujet de l'e-mail décodé.
    """
    decoded_parts = [] # Initialisation d'une liste pour stocker les parties décodées du sujet
    for part, encoding in email.header.decode_header(encoded_subject): # Parcourt les parties du sujet et leur encodage
        if isinstance(part, bytes): # Vérifie si la partie est en bytes
            decoded_parts.append(part.decode(encoding or 'utf-8')) # Décode la partie avec l'encodage spécifié ou utf-8 par défaut
        else:
            decoded_parts.append(part) # Ajoute la partie telle quelle si elle n'est pas en bytes
    return ''.join(decoded_parts) # Retourne le sujet décodé en concaténant toutes les parties


def fetch_emails_since_last_check(mail):
    """
    Récupère les e-mails reçus depuis la dernière vérification.

    :param mail (imaplib.IMAP4): L'objet IMAP utilisé pour se connecter à la boîte mail.
    :return (list): Une liste des e-mails récupérés.
    """
    try:
        mail.select('inbox') # Sélectionne la boîte de réception
        result, data = mail.search(None, 'UNSEEN')  # Rechercher les e-mails non lus
        email_ids = data[0].split() # Obtient les ID des e-mails non lus
        
        emails = []
        for email_id in email_ids:
            result, data = mail.fetch(email_id, '(RFC822)') # Récupère l'e-mail en format RFC822
            raw_email = data[0][1] # Récupère les données de l'e-mail brut
            msg = email.message_from_bytes(raw_email) # Convertit les données brutes en un objet Message
            emails.append(msg) # Ajoute l'e-mail à la liste
        return emails
    except Exception as e:
        print(f"Erreur lors de la récupération des e-mails : {e}")
        return []
    
    
def is_email_valid(email, num_boucle, periode):
    """
    Vérifie si une adresse e-mail est valide.

    :param email (str): L'adresse e-mail à valider.
    :param num_boucle (int): Numéro de la boucle d'autoconsommation.
    :param periode (str): Période (dateDebut_dateFin).
    :return (bool): True si l'adresse e-mail est valide, sinon False.
    """
    try:
        validate_email(email) # Valide l'adresse e-mail
        return True
    except EmailNotValidError:
        log_to_database(num_boucle, periode, datetime.now(), "", f"{email}, adresse mail incorrecte", 2, "ERROR")
        return False # Si une exception est levée, l'adresse e-mail n'est pas valide
    

def send_email(smtp_server, smtp_username, smtp_password, sender_email, receiver_email, subject, num_boucle, periode, zip_file_path):
    """
    Envoyer un e-mail avec le contenu des logs de la base de données.
    :param smtp_server (str): Serveur SMTP pour l'envoi de l'e-mail.
    :param smtp_username (str): Nom d'utilisateur pour l'authentification SMTP.
    :param smtp_password (str): Mot de passe pour l'authentification SMTP.
    :param sender_email (str): Adresse e-mail de l'expéditeur.
    :param receiver_email (str): Adresse e-mail du destinataire.
    :param subject (str): Sujet de l'e-mail.
    :param num_boucle (int): Numéro de la boucle d'autoconsommation.
    :param periode (str): Période (dateDebut_dateFin).
    :param zip_file_path (str): Chemin vers le fichier ZIP à attacher.
    """
    # Valider les adresses email
    if not is_email_valid(sender_email, num_boucle, periode):
        print(f"L'adresse email de l'expéditeur {sender_email} n'est pas valide.")
        return
    if not is_email_valid(receiver_email, num_boucle, periode):
        print(f"L'adresse email du destinataire {receiver_email} n'est pas valide.")
        return
    
    message = MIMEMultipart()
    message['From'] = sender_email
    message['To'] = receiver_email
    
    try:
        # Connexion à la base de données
        conn = connect_to_database()
        cursor = conn.cursor()
        
        # Requête SQL pour récupérer les logs de la base de données
        query = "SELECT NomFichier, Description, Type FROM Log WHERE Id_boucle = %s AND Periode = %s AND Importance = 2"
        values = (num_boucle, periode)
        
        # Exécution de la requête
        cursor.execute(query, values)
        logs = cursor.fetchall()
        
        # Compter le nombre d'erreurs dans les logs
        error_count = sum(1 for log in logs if log[2] == 'ERROR')
        
        # Modifier le sujet en fonction du nombre d'erreurs
        if error_count == 0:
            subject = "PubliExploit avec succès - " + subject
        else:
            subject = f"PubliExploit avec {error_count} erreurs - " + subject
        
        # Mettre à jour le sujet du message
        message['Subject'] = subject
        
        # Déterminer le message de statut en fonction du nombre d'erreurs
        if error_count == 0:
            status_message = "Traitement des fichiers avec <span style='color:green;font-weight:bold;'>succès</span>"
        else:
            status_message = f"Traitement des fichiers avec <span style='color:red;font-weight:bold;'>{error_count} erreurs</span>"
        
        # Préparer le contenu du message
        message_content = f"<p>{status_message}. Vous retrouverez en PJ de ce mail, le dossier de publications.</p><br><br>"
        
        # Ajouter les logs au contenu du message
        for log in logs:
            log_type = f"<span style='color:green;font-weight:bold;'>{log[2]}</span>" if log[2] == 'INFO' else f"<span style='color:red;font-weight:bold;'>{log[2]}</span>"
            message_content += f"<p>{log_type} - {log[0]} : {log[1]}</p>"
        
        # Attacher le contenu HTML
        message.attach(MIMEText(message_content, 'html'))
        
        # Encoder le nom du fichier pour gérer les espaces
        encoded_filename = urllib.parse.quote(os.path.basename(zip_file_path))
        
        # Attacher le fichier zip
        with open(zip_file_path, 'rb') as attachment:
            part = MIMEBase('application', 'octet-stream')
            part.set_payload(attachment.read())
            encoders.encode_base64(part)
            part.add_header('Content-Disposition', f'attachment; filename*=UTF-8\'\'{encoded_filename}')
            message.attach(part)
        
        # Création d'un contexte SSL sécurisé
        context = ssl.create_default_context()

        # Connexion au serveur SMTP avec SSL et un timeout de 30 secondes
        with smtplib.SMTP_SSL(smtp_server, 465, context=context, timeout=30) as server:
            server.ehlo()  # Peut aider à établir la connexion
            server.login(smtp_username, smtp_password)
            server.sendmail(sender_email, receiver_email, message.as_string())
        
        log_to_database(num_boucle, periode, datetime.now(), "", "E-mail envoyé avec succès.", 1, "INFO")

    except smtplib.SMTPDataError as e:
        if e.smtp_code == 552:
            log_to_database(num_boucle, periode, datetime.now(), "", f"Erreur : Le message est trop volumineux. Taille maximale dépassée : {e}", 2, "ERROR")
        else:
            log_to_database(num_boucle, periode, datetime.now(), "", f"Erreur SMTP de données : {e}", 2, "ERROR")
    except smtplib.SMTPServerDisconnected as e:
        log_to_database(num_boucle, periode, datetime.now(), "", f"Erreur de connexion au serveur SMTP : {e}", 2, "ERROR")
    except smtplib.SMTPAuthenticationError as e:
        log_to_database(num_boucle, periode, datetime.now(), "", f"Erreur d'authentification SMTP : {e}", 2, "ERROR")
    except smtplib.SMTPException as e:
        log_to_database(num_boucle, periode, datetime.now(), "", f"Erreur SMTP générale : {e}", 2, "ERROR")
    except Exception as e:
        log_to_database(num_boucle, periode, datetime.now(), "", f"Erreur inattendue lors de l'envoi de l'e-mail : {e}", 2, "ERROR")
        
    finally:
        # Fermeture de la connexion à la base de données
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()