# excel_utils.py
import openpyxl
import datetime
import os
from .database_utils import log_to_database


def write_to_excel(excel_file, num_boucle, date_debut, date_fin, password, folder_path):
    """
    Écrire les informations dans le fichier Excel.

    :param excel_file (str): Nom du fichier Excel (tableau des couples de mail)
    :param num_boucle (str): Numéro de boucle d'autoconsommation.
    :param date_debut (str): Date de début.
    :param date_fin (str): Date de fin.
    :param password (str): Mot de passe associé au dossier compressé.
    :param folder_path (str): Chemin du répertoire.
    :param logger (Logger): Objet logger pour enregistrer les informations et les erreurs.
    """    
    periode = f"{date_debut}_{date_fin}"
    excel_name = os.path.basename(excel_file)
    # Obtenir la date actuelle
    date_ajout = datetime.datetime.now()
    
    try:
        # Ouvrir le fichier Excel existant
        wb = openpyxl.load_workbook(excel_file)
        ws = wb.active
        
        # Ajouter les informations
        ws.append([num_boucle or "NULL", date_debut or "NULL", date_fin or "NULL", password or "NULL", folder_path or "NULL", "NULL", date_ajout])
        
        # Sauvegarder le fichier Excel
        wb.save(excel_file) 
        
        # Enregistrer un message d'information dans le journal
        log_to_database(num_boucle, periode, datetime.datetime.now(), f"{excel_name}", f"Ligne ajoutée au fichier Excel : {num_boucle}, {date_debut}, {date_fin}, {password}, {folder_path}", 1, "INFO")
    except Exception as e:
        # En cas d'erreur, enregistrer un message d'erreur dans le journal
        log_to_database(num_boucle, periode, datetime.datetime.now(), f"{excel_name}", f"Erreur lors de l'écriture dans le fichier Excel : {e}", 2, "ERROR")
    finally:
        # Fermer le fichier Excel pour libérer les ressources
        wb.close()

def find_matching_entries(excel_file, num_boucle, periode):
    """
    Recherche les lignes partageant les mêmes caractéristiques de boucle, date de début et date de fin.
    Met à jour le statut des lignes correspondantes et renvoie le mot de passe et le répertoire associés.

    :param excel_file (str): Chemin vers le fichier Excel.
    :param num_boucle (int): Numéro de la boucle d'autoconsommation.
    :param periode (str): Période (dateDebut_dateFin).
    :return (tuple): Mot de passe et répertoire associés aux entrées correspondantes.
    """
    excel_name = os.path.basename(excel_file)
    try:
        # Charger le fichier Excel
        wb = openpyxl.load_workbook(excel_file)
        ws = wb.active

        # Dictionnaire pour stocker les informations par clé (boucle, date_debut, date_fin)
        entries_dict = {}

        # Parcourir chaque ligne du fichier Excel
        for row in ws.iter_rows(min_row=2):  # Utiliser min_row=2 pour ignorer l'en-tête
            boucle = row[0].value
            date_debut = row[1].value
            date_fin = row[2].value
            mdp = row[3].value
            repertoire = row[4].value
            status = row[5].value
            date_entree = row[6].value

            # Ignorer les lignes dont le statut n'est pas NULL
            if status != "NULL":
                continue

            if status == "NULL":
                # Vérifier si la ligne a été ajoutée il y a plus de 5 jours
                if (datetime.datetime.now() - date_entree).days > 5:
                    log_to_database(num_boucle, periode, datetime.datetime.now(), f"{excel_name}", f"Ligne ajoutée il y a plus de 5 jours : {boucle}, {date_debut}, {date_fin}, {repertoire}", 2, "WARNING")

            # Clé pour le dictionnaire : (boucle, date_debut, date_fin)
            key = (boucle, date_debut, date_fin)

            # Ajouter les informations au dictionnaire
            if key in entries_dict:
                entries_dict[key].append(row)
            else:
                entries_dict[key] = [row]

        # Rechercher les couples et mettre à jour le statut
        for key, rows in entries_dict.items():
            if len(rows) > 1:
                # Trouver le mot de passe et le répertoire à renvoyer
                for row in rows:
                    if row[3].value != "NULL":  # Vérifier si le mot de passe n'est pas NULL
                        mdp = row[3].value
                        repertoire = row[4].value

                        # Mettre à jour le statut des lignes correspondantes
                        for r in rows:
                            r[5].value = "OK"

                        # Sauvegarder le fichier Excel mis à jour
                        wb.save(excel_file)
                        log_to_database(num_boucle, periode, datetime.datetime.now(), f"{excel_name}", f"Couple trouvé et statut mis à jour pour les lignes : {key}", 1, "INFO")

                        # Fermer le fichier Excel après l'avoir sauvegardé
                        wb.close()

                        return mdp, repertoire

        # Fermer le fichier Excel si aucun couple n'a été trouvé
        wb.close()
        return None, None

    except Exception as e:
        # Enregistrer une erreur en cas de problème lors de la lecture du fichier Excel
        log_to_database(num_boucle, periode, datetime.datetime.now(), f"{excel_name}", f"Une erreur s'est produite lors de la lecture du fichier Excel : {e}", 2, "ERROR")
        return None, None
    
def remove_ok_status_rows(excel_file, num_boucle, periode):
    """
    Supprimer les lignes avec la colonne STATUS valant 'OK' et réorganiser le fichier Excel.

    :param excel_file (str): Chemin vers le fichier Excel.
    :param num_boucle (int): Numéro de la boucle d'autoconsommation.
    :param periode (str): Période (dateDebut_dateFin).
    """
    excel_name = os.path.basename(excel_file)
    try:
        # Charger le fichier Excel
        wb = openpyxl.load_workbook(excel_file)
        ws = wb.active

        # Liste pour stocker les lignes à conserver
        rows_to_keep = []

        # Parcourir les lignes du fichier Excel
        for row in ws.iter_rows(min_row=2, values_only=True):
            status = row[5]
            if status != "OK":
                rows_to_keep.append(row)

        # Supprimer toutes les lignes du fichier Excel
        ws.delete_rows(2, ws.max_row)
        log_to_database(num_boucle, periode, datetime.datetime.now(), f"{excel_name}", "Couple supprimé de la liste.", 1, "INFO")

        # Réécrire les lignes à conserver
        for row in rows_to_keep:
            ws.append(row)
        
        # Sauvegarder le fichier Excel réorganisé
        wb.save(excel_file)
        log_to_database(num_boucle, periode, datetime.datetime.now(), f"{excel_name}", "Fichier Excel sauvegardé après réorganisation.", 1, "INFO")

    except Exception as e:
        # Enregistrer une erreur en cas de problème lors de la réorganisation du fichier Excel
        log_to_database(num_boucle, periode, datetime.datetime.now(), f"{excel_name}", f"Une erreur s'est produite lors de la réorganisation du fichier Excel : {e}", 2, "ERROR")
    finally:
        # Fermer le fichier Excel
        wb.close()